unit Lb.SysUtils;

interface

{$IFDEF DEBUG}
//  {$DEFINE DB_LOG}
{$ENDIF}

uses
  System.SysUtils,
  System.Types,
  System.UITypes,
  System.Classes,
  System.Variants,
  System.Generics.Collections,
  Lb.ReadPrice;

type
  ///<summary>
  /// Òèï êàòåãîğèé
  ///</summary>
  TTypeÑriterion = (tcOpen, tcClose);

  ///<summary>
  /// Òèï íàïğàâëåíèå
  ///</summary>
  TTypeSide = (tsBuy,tsSell);

  ///<summary>
  /// Òèï ïîçèöèè
  ///</summary>
  TTypePosition = (tpNull, tpOpen, tpClose);

type
  TTrader = class;
  TPositionTrade = class;

  ///<summary>
  /// Ñîáûòèå òğåéäåğà íà îòêğûòèå ïîçèöèè
  ///</summary>
  TEventOperationTrade = procedure(
    ATrader: TTrader;               // Óêàçàòåëü íà òğåéäîğà
    ATypeÑriterion: TTypeÑriterion; // Íàïğîâëåíèå ïîçèöèè
    ATypeSide: TTypeSide;           // Íàïğîâëåíèå ñëåäêè
    AQty: Double                    // Êîëè÷åñòâî
  ) of object;

  ///<summary>
  /// Êğèòåğèé îòğûòèå ïîçèöèè
  ///</summary>
  TÑriterion = class(TObject)
  public
    RSI: Double;                   // Çíà÷åíèå èíäèêàòîğà
    ReActiveRSI: Double;           // Çíà÷åíèå èíäèêàòîğà, äëÿ àêòèâàöèè êğåòåğèÿ
    Qty: Double;                   // Êîëè÷åñòâî
    IsActive: Boolean;             // Ñîñòîÿíèå êğèòåğèÿ
    TypeÑriterion: TTypeÑriterion; // Òèïà êğèòåğèÿ
  public
    constructor Create; virtual;
    procedure Default;
  end;
  TÑriterionList = TObjectList<TÑriterion>;

  ///<summary>Òğåéäåğ</summary>
  TTrader = class(TObject)
  private
    FID: Integer;
    FSide: TTypeSide;
    FÑriterions: TÑriterionList;
  private
    FOnOperationTrade: TEventOperationTrade;
  protected
    procedure DoEventOperationTrade(ATypeÑriterion: TTypeÑriterion; ATypeSide: TTypeSide; AQty: Double);  virtual;
    procedure DoOperationTrade(AÑriterion: TÑriterion);
  public
    constructor Create; virtual;
    destructor Destroy; override;
    procedure SetUpDate(const AValueRSI: Double);
    ///<summary>Êîëè÷åñòâî êğèòåğèåâ</summary>
    procedure CreateÑriterion(const ACount: Integer = 1);
    ///<summary>Ñïèñîê êğèòåğèåâ</summary>
    property Ñriterions: TÑriterionList read FÑriterions;
    ///<summary>Íàïğàâëåíèå çàÿâêè</summary>
    property Side: TTypeSide read FSide write FSide;
    ///<summary>Íîìåğ òğåéäåğà</summary>
    property ID: Integer read FID write FID;
    ///<summary>Ñîáûòèå òğåéäåğà</summary>
    property OnOperationTrade: TEventOperationTrade write FOnOperationTrade;
  end;
  TTraderList = TObjectList<TTrader>;

  ///<summary>Ñäåëêà - òîğãîâëÿ</summary>
  TTrade = record
    Date : TDateTime;
    Time : TDateTime;
    Price: Double;
    Qty  : Double;
    Side : TTypeSide;
  private
    function GetValue: Double;
  public
    property Value: Double read GetValue;
  end;
  TTradeList = TList<TTrade>;

  ///<summary>Ïîçèöèÿ ïîñëåäêè</summary>
  TPositionTrade = class(TObject)
  private
    FTrader: TTrader;
    FCloseTrade: TTrade;
    FTrades: TTradeList;
    FTypePosition: TTypePosition;
    function GetSide: TTypeSide;
    function GetQty: Double;
    function GetValue: Double;
    function GetPrice: Double;
    function GetProfit: Double;
  public
    constructor Create; virtual;
    destructor Destroy; override;
    ///<summary>Îòêğûòèå ïîçèöèè</summary>
    procedure SetOpenTrade(ADate, ATime: TDateTime; APrice, AQty: Double; ASide: TTypeSide);
    ///<summary>Çàêğûòèÿ ïîçèöèè</summary>
    procedure SetCloseTrade(ADate, ATime: TDateTime; APrice, AQty: Double; ASide: TTypeSide);
    ///<summary>Òèï ïîçèöèè</summary>
    property TypePosition: TTypePosition read FTypePosition;
    ///<summary>Êòî ñîâåğøèë òîğãîâóş îïåğàöèş</summary>
    property Trader: TTrader read FTrader write FTrader;
    ///<summary>Ñïèñîê ïğîâåäåííûõ ñäåëîê</summary>
    property Trades: TTradeList read FTrades;
    ///<summary>Ñäåëêà çàêğûòèå ïîçèöèè</summary>
    property CloseTrade: TTrade read FCloseTrade;
  public
    property Price: Double read GetPrice;
    property Value: Double read GetValue;
    property Qty  : Double read GetQty;
    property Side : TTypeSide read GetSide;
    property Profit: Double read GetProfit;
  end;
  TPositionTradeList = TObjectList<TPositionTrade>;

  ///<summary>Ğàáî÷èé òğåéäåğ</summary>
  TWorkTrader = class(TTrader)
  private
    FCandel: TCandel;
    FActivePosition: TPositionTrade;
    FPositionTrades: TPositionTradeList;
    function GetProfit: Double;
    function GetPositivCountProfit: Double;
  protected
    procedure DoEventOperationTrade(ATypeÑriterion: TTypeÑriterion; ASide: TTypeSide; AQty: Double); override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure SetUpDateCandel(ACandel: TCandel; AValueRSI: Double);
    property ActivePosition: TPositionTrade read FActivePosition;
    property PositionTrades: TPositionTradeList read FPositionTrades;
    ///<summary>Ïîëó÷åííàÿ ïğèáûëü ïî çàêğûòûì ïîçèöèÿì</summary>
    property Profit: Double read GetProfit;
  public
    ///<summary>Êîëè÷åñòâî ïîçèòèâíûú ïîçèöèé</summary>
    property PositivCountProfit: Double read GetPositivCountProfit;
  end;
  TWorkTraderList = TObjectList<TWorkTrader>;


function GetTypeSideToStr(const ASide: TTypeSide): String;

implementation

uses
  UnitMainForm;

function GetTypeSideToStr(const ASide: TTypeSide): String;
begin
  Result := '';
  case ASide of
    tsBuy: Result := 'Buy';
    tsSell: Result := 'Sell';
  end;
end;

function GetUpRSI(const AValue, AParam: Double): Boolean;
begin
  Result := AParam < AValue;
end;

function GetDownRSI(const AValue, AParam: Double): Boolean;
begin
  Result := AParam > AValue;
end;

{ TÑriterion }

constructor TÑriterion.Create;
begin
  Default;
end;

procedure TÑriterion.Default;
begin
  RSI := 0;
  ReActiveRSI := 0;
  Qty := 0;
  IsActive := False;
end;

{ TTrader }

constructor TTrader.Create;
begin
  FÑriterions := TÑriterionList.Create;
end;

destructor TTrader.Destroy;
begin
  FÑriterions.Clear;
  FreeAndNil(FÑriterions);
  inherited;
end;

procedure TTrader.DoEventOperationTrade(ATypeÑriterion: TTypeÑriterion; ATypeSide: TTypeSide; AQty: Double);
begin
  if Assigned(FOnOperationTrade) then
    FOnOperationTrade(Self,ATypeÑriterion,FSide,AQty);
end;

procedure TTrader.DoOperationTrade(AÑriterion: TÑriterion);

  function _CrossSide(ASide: TTypeSide): TTypeSide;
  begin
    if ASide = tsBuy then
      Result := tsSell
    else
      Result := tsBuy;
  end;

begin
  case AÑriterion.TypeÑriterion of
    tcOpen: begin
      DoEventOperationTrade(AÑriterion.TypeÑriterion,FSide,AÑriterion.Qty);
    end;
    tcClose: begin
      DoEventOperationTrade(AÑriterion.TypeÑriterion,_CrossSide(FSide),AÑriterion.Qty);
    end;
  end;
end;

procedure TTrader.CreateÑriterion(const ACount: Integer);
var
  xÑriterion: TÑriterion;
  i: Integer;
begin
  // Ïîñëåäíèé êğåòåğèé íà çàêğûòèå
  FÑriterions.Clear;
  for i := 0 to ACount do
  begin
    xÑriterion := TÑriterion.Create;
    xÑriterion.Default;
    if i = (ACount - 1) then
      xÑriterion.TypeÑriterion := TTypeÑriterion.tcOpen
    else
      xÑriterion.TypeÑriterion := TTypeÑriterion.tcClose;
    FÑriterions.Add(xÑriterion);
  end;
end;

procedure TTrader.SetUpDate(const AValueRSI: Double);

  procedure _ActiveÑriterion(AÑriterion: TÑriterion);
  begin
    // Ïğîèçâîäèì àêòèâàöèş êğèòåğèÿ
    case FSide of
      tsBuy: begin
        case AÑriterion.TypeÑriterion of
          tcOpen: if GetDownRSI(AValueRSI,AÑriterion.RSI) then
          begin
            DoOperationTrade(AÑriterion);
            AÑriterion.IsActive := False;
          end;
          tcClose: if GetUpRSI(AValueRSI,AÑriterion.RSI) then
          begin
            DoOperationTrade(AÑriterion);
            AÑriterion.IsActive := False;
          end;
        end;
      end;
      tsSell: begin
        case AÑriterion.TypeÑriterion of
          tcOpen: if GetUpRSI(AValueRSI, AÑriterion.RSI) then
          begin
            DoOperationTrade(AÑriterion);
            AÑriterion.IsActive := False;
          end;
          tcClose: if GetDownRSI(AValueRSI, AÑriterion.RSI) then
          begin
            DoOperationTrade(AÑriterion);
            AÑriterion.IsActive := False;
          end;
        end;
      end;
    end;
  end;

  procedure _ReActiveÑriterion(AÑriterion: TÑriterion);
  begin
    // Ïğîèçâîäèì ğåàêòèâàöèş êğèòåğèÿ
    case FSide of
      tsBuy: begin
        case AÑriterion.TypeÑriterion of
          tcOpen: if GetUpRSI(AValueRSI, AÑriterion.ReActiveRSI) then
            AÑriterion.IsActive := True;
          tcClose: if GetDownRSI(AValueRSI, AÑriterion.ReActiveRSI) then
            AÑriterion.IsActive := True;
        end;
      end;
      tsSell: begin
        case AÑriterion.TypeÑriterion of
          tcOpen: if GetDownRSI(AValueRSI, AÑriterion.ReActiveRSI) then
            AÑriterion.IsActive := True;
          tcClose: if AÑriterion.ReActiveRSI > AValueRSI then
            AÑriterion.IsActive := True;
        end;
      end;
    end;
  end;

var
  xÑriterion: TÑriterion;
  i, iCount: Integer;
begin
  iCount := FÑriterions.Count;
  if iCount > 0 then
    for i := 0 to iCount - 1 do
    begin
      xÑriterion := FÑriterions[i];
      if xÑriterion.IsActive then
        _ActiveÑriterion(xÑriterion)
      else
        _ReActiveÑriterion(xÑriterion);
    end;
end;

{ TTrade }

function TTrade.GetValue: Double;
begin
  Result := Price * Qty;
end;

{ TPositionTrade }

constructor TPositionTrade.Create;
begin
  FTrades := TTradeList.Create;
  FTypePosition := TTypePosition.tpNull;
end;

destructor TPositionTrade.Destroy;
begin
  FreeAndNil(FTrades);
  inherited;
end;

function TPositionTrade.GetSide: TTypeSide;
begin
  if FTrades.Count > 0 then
    Result := FTrades[0].Side
  else
    raise Exception.Create('Error Message: Íåò âîçìîæíîñòè îïğåäåëèòü íàïğàâëåíèå ïîçèöèè');
end;

function TPositionTrade.GetPrice: Double;
begin
  Result := Self.Value/Self.Qty;
end;


function TPositionTrade.GetQty: Double;
var
  xQty: Double;
begin
  if FTrades.Count > 0 then
  begin
    xQty := 0;
    for var xTrade in FTrades do
      xQty := xQty + xTrade.Qty;
    Result := xQty;
  end
  else
    raise Exception.Create('Error Message: Íåò âîçìîæíîñòè îïğåäåëèòü ğàçìåğ ïîçèöèè');
end;

function TPositionTrade.GetValue: Double;
var
  xValue: Double;
begin
  if FTrades.Count > 0 then
  begin
    xValue := 0;
    for var xTrade in FTrades do
      xValue := xValue + xTrade.Value;
    Result := xValue;
  end
  else
    raise Exception.Create('Error Message: Íåò âîçìîæíîñòè îïğåäåëèòü îáúåì ïîçèöèè');
end;

function TPositionTrade.GetProfit: Double;
begin
  Result := 0;
  if FTypePosition = TTypePosition.tpClose then
  begin
    case Side of
      tsBuy: Result := FCloseTrade.Value - Self.Value;
      tsSell: Result := Self.Value - FCloseTrade.Value;
    end;
  end;
end;

procedure TPositionTrade.SetOpenTrade(ADate, ATime: TDateTime; APrice, AQty: Double; ASide: TTypeSide);

  function _GetQty: Double;
  begin
    Result := 0;
    if FTrades.Count > 0 then
      Result := FTrades[FTrades.Count - 1].Qty;
  end;

var
  xTrade: TTrade;
begin
  if FTrades.Count < 1 then
  begin
    with xTrade do
    begin
      Date := ADate;
      Time := ATime;
      Price:= APrice;
      Qty  := _GetQty + AQty;
      Side := ASide;
    end;
    FTrades.Add(xTrade);
    FTypePosition := TTypePosition.tpOpen;
  end;
end;

procedure TPositionTrade.SetCloseTrade(ADate, ATime: TDateTime; APrice, AQty: Double; ASide: TTypeSide);
begin
  if FTypePosition = TTypePosition.tpOpen then
  begin
    with FCloseTrade do
    begin
      Date := ADate;
      Time := ATime;
      Price:= APrice;
      Qty  := AQty;
      Side := ASide;
    end;
    FTypePosition := TTypePosition.tpClose;
  end;
end;

{ TWorkTrader }

constructor TWorkTrader.Create;
begin
  inherited;
  FActivePosition := nil;
  FPositionTrades := TPositionTradeList.Create;
end;

destructor TWorkTrader.Destroy;
begin
  FPositionTrades.Clear;
  FreeAndNil(FPositionTrades);
  inherited;
end;

procedure TWorkTrader.DoEventOperationTrade(ATypeÑriterion: TTypeÑriterion;
  ASide: TTypeSide; AQty: Double);
begin
  inherited;
  if Assigned(FActivePosition) then
  begin
    case ATypeÑriterion of
      tcOpen: FActivePosition.SetOpenTrade(FCandel.Date, FCandel.Time, FCandel.Close, AQty, ASide);
      tcClose: begin
        FActivePosition.SetCloseTrade(FCandel.Date, FCandel.Time, FCandel.Close, FActivePosition.Qty, ASide);
        FActivePosition := nil;
      end;
    end;
  end
  else
    if ATypeÑriterion = tcOpen then
    begin
      FActivePosition := TPositionTrade.Create;
      FActivePosition.Trader := TTrader(Self);
      FActivePosition.SetOpenTrade(FCandel.Date, FCandel.Time, FCandel.Close, AQty, ASide);
      FPositionTrades.Add(FActivePosition);
    end;
end;

procedure TWorkTrader.SetUpDateCandel(ACandel: TCandel; AValueRSI: Double);
begin
  {$IFDEF DB_LOG}
  Log('TWorkTrader.SetUpDateCandel:');
  {$ENDIF}
  FCandel := ACandel;
  SetUpDate(AValueRSI);
end;

function TWorkTrader.GetProfit: Double;
var
  xSum: Double;
  i, iCount: Integer;
  xPositionTrade: TPositionTrade;
begin
  xSum := 0;
  iCount := FPositionTrades.Count;
  if iCount > 0 then
    for i := 0 to iCount - 1 do
    begin
      xPositionTrade := FPositionTrades[i];
      xSum := xSum + xPositionTrade.Profit;
    end;
  Result := xSum;
end;


function TWorkTrader.GetPositivCountProfit: Double;
var
  xCount: Integer;
  i, iCount: Integer;
  xPositionTrade: TPositionTrade;
begin
  xCount := 0;
  iCount := FPositionTrades.Count;
  if iCount > 0 then
    for i := 0 to iCount - 1 do
    begin
      xPositionTrade := FPositionTrades[i];
      if xPositionTrade.Profit > 0 then
        xCount := xCount + 1;
    end;
  Result := xCount;
end;

end.
